#!/usr/bin/env bash
# Python development environment setup script - PEP 668 compatible
# Part of Enhanced Terminal Environment
# Version: 3.0

# Exit on error, undefined variables, and propagate pipe failures
set -euo pipefail

# Define colors for output
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly YELLOW='\033[0;33m'
readonly RED='\033[0;31m'
readonly NC='\033[0m' # No Color

# Script directory (resolving symlinks)
readonly SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"

# Log functions for consistent output
log_info() {
    echo -e "${BLUE}INFO: $1${NC}"
}

log_success() {
    echo -e "${GREEN}SUCCESS: $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}WARNING: $1${NC}"
}

log_error() {
    echo -e "${RED}ERROR: $1${NC}" >&2
}

# Error handling function
handle_error() {
    log_error "$1"
    exit 1
}

# Check if a command exists
command_exists() {
    command -v "$1" &> /dev/null
}

# Create project templates directory
create_templates_dir() {
    local dir="$HOME/.local/share/python-templates"
    
    echo "Creating Python templates directory: $dir"
    mkdir -p "$dir" || { echo -e "${RED}ERROR: Failed to create templates directory${NC}" >&2; return 1; }
    
    # Explicitly return the directory path
    echo "$dir"
}

# Add function to .zshrc if it doesn't exist
add_function_to_zshrc() {
    local function_name="$1"
    local function_path="$2"
    
    if ! grep -q "${function_name}()" "$HOME/.zshrc"; then
        log_info "Adding ${function_name} function to .zshrc"
        cat >> "$HOME/.zshrc" << EOF

# Python project creator function
${function_name}() {
    ${function_path} "\$@"
}
EOF
    else
        log_success "${function_name} function already exists in .zshrc"
    fi
}

# Main function
main() {
    log_info "Setting up Python development environment..."

    # Detect OS
    if [[ "$OSTYPE" == "darwin"* ]]; then
        readonly OS="macOS"
        log_info "Detected macOS system"
        
        # Check Python installation
        if command_exists python3; then
            PYTHON_VERSION=$(python3 --version | cut -d' ' -f2)
            log_success "Python already installed: $PYTHON_VERSION"
        else
            log_info "Installing Python via Homebrew..."
            if ! brew install python; then
                handle_error "Failed to install Python"
            fi
        fi
        
        # Install pipx using Homebrew (PEP 668 compatible approach)
        if ! command_exists pipx; then
            log_info "Installing pipx via Homebrew..."
            if ! brew install pipx; then
                log_warning "Failed to install pipx via Homebrew, trying pip installation..."
                python3 -m pip install --user pipx || handle_error "Failed to install pipx"
            fi
            
            # Ensure pipx binaries are in PATH
            if command_exists pipx; then
                log_info "Configuring pipx..."
                pipx ensurepath || log_warning "Failed to add pipx to PATH"
            fi
        else
            log_success "pipx already installed"
        fi
        
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        readonly OS="Linux"
        log_info "Detected Linux system"
        
        # Update package lists
        log_info "Updating package lists..."
        sudo apt update || handle_error "Failed to update package lists"
        
        # Install Python and related tools on Linux
        if command_exists python3; then
            PYTHON_VERSION=$(python3 --version | cut -d' ' -f2)
            log_success "Python already installed: $PYTHON_VERSION"
        else
            log_info "Installing Python 3..."
            sudo apt install -y python3 python3-dev python3-venv python3-pip || 
                handle_error "Failed to install Python"
        fi
        
        # Install pipx on Linux
        if ! command_exists pipx; then
            log_info "Installing pipx..."
            # Try apt first, then pip if apt fails
            if ! sudo apt install -y python3-pipx; then
                log_warning "Failed to install pipx via apt, trying pip installation..."
                python3 -m pip install --user pipx || handle_error "Failed to install pipx"
            fi
            
            # Ensure pipx is in path
            if command_exists pipx; then
                pipx ensurepath || log_warning "Failed to add pipx to PATH"
            fi
        else
            log_success "pipx already installed"
        fi
    else
        handle_error "Unsupported operating system: $OSTYPE"
    fi

    # Install Poetry using their official installer (more reliable approach)
    if ! command_exists poetry; then
        log_info "Installing Poetry (Python package manager)..."
        
        # Create temporary directory for the installer
        TEMPDIR=$(mktemp -d)
        INSTALLER="$TEMPDIR/install-poetry.py"
        
        # Download the installer
        if curl -sSL https://install.python-poetry.org -o "$INSTALLER"; then
            # Run the installer with --user flag to avoid system Python modifications
            python3 "$INSTALLER" --yes || handle_error "Failed to install Poetry"
            rm -rf "$TEMPDIR"
            
            # Add Poetry to PATH if not already
            POETRY_BIN_PATH="$HOME/.poetry/bin"
            if [[ ! -d "$HOME/.local/bin" ]]; then
                mkdir -p "$HOME/.local/bin"
            fi
            
            # Add to zshrc if not already there
            if ! grep -q "poetry/bin" "$HOME/.zshrc"; then
                echo 'export PATH="$HOME/.local/bin:$HOME/.poetry/bin:$PATH"' >> "$HOME/.zshrc"
                log_info "Added Poetry to PATH in .zshrc"
            fi
            
            log_info "You may need to restart your shell or run 'source ~/.zshrc' for Poetry to be available"
            
            # For immediate availability in this script
            export PATH="$HOME/.local/bin:$POETRY_BIN_PATH:$PATH"
        else
            log_warning "Failed to download Poetry installer, skipping Poetry installation"
        fi
    else
        log_success "Poetry already installed"
        # Try to update but don't fail if it doesn't work
        poetry self update 2>/dev/null || log_warning "Failed to update Poetry, continuing anyway..."
    fi

    # Install essential Python development tools using pipx
    if command_exists pipx; then
        log_info "Installing essential Python development tools..."

        # List of tools to install
        local PYTHON_TOOLS=(
            "ipython"
            "black"
            "flake8"
            "pylint"
            "mypy"
            "pytest"
            "httpie"
        )

        # Install each tool if not already installed
        for tool in "${PYTHON_TOOLS[@]}"; do
            if ! command_exists "$tool"; then
                log_info "Installing $tool with pipx..."
                if ! pipx install "$tool" 2>/dev/null; then
                    log_warning "Failed to install $tool, continuing anyway..."
                fi
            else
                log_success "$tool already installed, skipping..."
            fi
        done

        # Install pytest-cov as a pytest plugin if pytest was successfully installed
        if command_exists pytest; then
            log_info "Adding pytest-cov plugin to pytest..."
            if ! pipx inject pytest pytest-cov 2>/dev/null; then
                log_warning "Failed to add pytest-cov plugin, continuing anyway..."
            fi
        fi
    else
        log_warning "pipx is not available, skipping installation of Python development tools"
    fi

    # Create Python project template
    local templates_dir
    templates_dir=$(create_templates_dir)
    local template_script="$templates_dir/basic_project.sh"

    # Create Python project template script
    log_info "Creating Python project template..."
    cat > "$template_script" << 'EOL'
#!/usr/bin/env bash
# Basic Python project template generator - PEP 668 compliant

set -euo pipefail

# Define colors for output
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly YELLOW='\033[0;33m'
readonly RED='\033[0;31m'
readonly NC='\033[0m' # No Color

if [ "$#" -ne 1 ]; then
    echo -e "${RED}Usage: pyproject <projectname>${NC}"
    exit 1
fi

PROJECT_NAME="$1"
# Convert project name to valid Python package name
PACKAGE_NAME=$(echo "$PROJECT_NAME" | tr '-' '_' | tr '[:upper:]' '[:lower:]')

# Check if directory already exists
if [[ -d "$PROJECT_NAME" ]]; then
    echo -e "${RED}Error: Directory '$PROJECT_NAME' already exists.${NC}"
    exit 1
fi

echo -e "${BLUE}Creating project: $PROJECT_NAME${NC}"
mkdir -p "$PROJECT_NAME"
cd "$PROJECT_NAME" || exit 1

# Create virtual environment
echo -e "${BLUE}Setting up virtual environment...${NC}"
python3 -m venv venv
echo -e "${GREEN}Created virtual environment at ./venv${NC}"

# Create project structure
echo -e "${BLUE}Creating project structure...${NC}"
mkdir -p "$PACKAGE_NAME/tests"

# Create main module
mkdir -p "$PACKAGE_NAME/$PACKAGE_NAME"
touch "$PACKAGE_NAME/$PACKAGE_NAME/__init__.py"

# Create main.py with proper content
cat > "$PACKAGE_NAME/$PACKAGE_NAME/main.py" << EOF
"""Main entry point of the application."""


def main():
    """Main entry point of the application."""
    print("Hello, World!")


if __name__ == "__main__":
    main()
EOF

# Create test file
cat > "$PACKAGE_NAME/tests/__init__.py" << EOF
"""Test package."""
EOF

cat > "$PACKAGE_NAME/tests/test_main.py" << EOF
"""Test the main module."""
import pytest
from ${PACKAGE_NAME}.main import main


def test_main():
    """Test the main function."""
    # This is a placeholder test
    assert True
EOF

# Create README
cat > "$PACKAGE_NAME/README.md" << EOF
# $PROJECT_NAME

A Python project.

## Installation

\`\`\`bash
# Create and activate virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\\Scripts\\activate

# Install development dependencies
pip install -e ".[dev]"
\`\`\`

## Usage

\`\`\`python
from $PACKAGE_NAME import main
main.main()
\`\`\`

## Development

\`\`\`bash
# Run tests
pytest

# Format code
black $PACKAGE_NAME
\`\`\`

## Acknowledgements

This project was developed with assistance from Anthropic's Claude AI assistant, which helped with:
- Documentation writing and organization
- Code structure suggestions
- Troubleshooting and debugging assistance

Claude was used as a development aid while all final implementation decisions and code review were performed by Joshua Michael Hall.

## Disclaimer

This software is provided "as is", without warranty of any kind, express or implied. The authors or copyright holders shall not be liable for any claim, damages or other liability arising from the use of the software.

This project is a work in progress and may contain bugs or incomplete features. Users are encouraged to report any issues they encounter.
EOF

# Create pyproject.toml (modern approach)
cat > "$PACKAGE_NAME/pyproject.toml" << EOF
[build-system]
requires = ["setuptools>=42", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "$PROJECT_NAME"
version = "0.1.0"
description = "A Python project"
readme = "README.md"
authors = [
    {name = "Joshua Michael Hall", email = "your.email@example.com"}
]
requires-python = ">=3.9"
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.9",
]

dependencies = [
    # Add runtime dependencies here
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "black>=23.0.0",
    "pylint>=2.17.0",
    "mypy>=1.4.0",
]

[project.urls]
"Homepage" = "https://github.com/joshuamichaelhall/${PROJECT_NAME}"
"Bug Tracker" = "https://github.com/joshuamichaelhall/${PROJECT_NAME}/issues"

[project.scripts]
${PACKAGE_NAME} = "${PACKAGE_NAME}.main:main"
EOF

# Create .gitignore
cat > "$PACKAGE_NAME/.gitignore" << 'EOF'
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# Distribution / packaging
dist/
build/
*.egg-info/

# Virtual environments
.venv/
venv/
ENV/

# Testing
.coverage
htmlcov/
.pytest_cache/

# Mypy
.mypy_cache/

# IDE specific files
.idea/
.vscode/
*.swp
*.swo

# OS specific files
.DS_Store
EOF

# Initialize Git repository
cd "$PACKAGE_NAME" || exit 1
echo -e "${BLUE}Initializing Git repository...${NC}"
git init
git add .
git commit -m "Initial project structure" --no-verify

echo -e "${GREEN}Python project $PROJECT_NAME created successfully with virtual environment!${NC}"
echo
echo -e "${YELLOW}To activate the environment, run:${NC}"
echo -e "  cd ${PROJECT_NAME}"
echo -e "  source venv/bin/activate" 
echo -e "${YELLOW}Then install development dependencies:${NC}"
echo -e "  pip install -e \".[dev]\""
EOL

    # Make template executable
    chmod +x "$template_script" || handle_error "Failed to make template script executable" || handle_error "Failed to make template script executable"

    # Add function to .zshrc
    add_function_to_zshrc "pyproject" "$template_script"

    log_success "Python environment setup complete!"
    log_info "New commands available:"
    log_info "  pyproject - Create a new Python project with virtual environment"
    if command_exists poetry; then
        log_info "  poetry - Manage Python packages and dependencies"
    fi
    if command_exists pipx; then
        log_info "  pipx - Install and run Python applications in isolated environments"
    fi
    log_warning "Restart your shell or run 'source ~/.zshrc' to use the new commands"
}

# Trap for cleanup on script exit
cleanup() {
    local exit_code=$?
    if [ $exit_code -ne 0 ]; then
        log_error "Script failed with exit code $exit_code"
    fi
    exit $exit_code
}
trap cleanup EXIT

# Run the main function
main "$@"